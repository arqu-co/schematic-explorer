<!-- Generated by Convext (project_slug: "arqu-co/schematic-explorer")

## CONVEXT MCP WORKFLOW - READ THIS CAREFULLY

This project is managed by Convext. You have access to Convext MCP tools.

### Finding the Project Slug
The project_slug for ALL Convext MCP tool calls is: "arqu-co/schematic-explorer"
You can also read it from .convext/config.json in the working directory.

### REQUIRED Workflow When Completing Tasks

1. **Before starting work**: Check for existing plans and tasks
   - Call get_plans_tool with project_slug: "arqu-co/schematic-explorer"
   - Call get_tasks_tool to see pending tasks for any plan

2. **Work on a task**: Complete the implementation
   - Write code, run tests, ensure everything works
   - Do NOT mark the task complete yet

3. **Commit with task reference**: Link the commit to the Convext task
   - Include task ID in commit message: `feat: <description> [convext #<task_id>]`
   - Example: `git commit -m "feat: Add user authentication [convext #261]"`

4. **Update task with commit SHA**: After committing, update Convext
   - Get the commit SHA: `git rev-parse HEAD`
   - Call manage_task_tool with:
     - action: "update"
     - task_id: <the task ID>
     - status: "completed"
     - commit_sha: <the SHA from git rev-parse HEAD>
     - pull_request_url: <if a PR exists>

5. **Report completion** (optional, for compliance check):
   - Call report_task_complete_tool with commit_sha and files_changed

### Critical Rules
- NEVER mark a task complete without a commit SHA
- ALWAYS commit before updating task status
- ALWAYS include task ID in commit message for traceability
- Commit links to Convext task, task links back to commit = full traceability
-->

# schematic-explorer - Convext

## Metadata

- **Project:** schematic-explorer
- **Languages:** typescript, go
- **Frameworks:** react
- **Revision:** `AushBpnc`

## Rules

### Critical Severity

#### No mocking the class under test

**Category:** testing

When writing unit tests, never mock the class you are testing.
You should test the real instance of the class to ensure it behaves correctly.
Mocking the class under test defeats the purpose of the test and can hide bugs.

#### Never ignore failing tests

**Category:** testing

If you encounter a test failure, do not ignore it or mark it as skipped.
- Investigate the root cause immediately
- If it's a real bug, fix it before proceeding
- If it's a flaky test, fix the flakiness
- Never wave off failures as "pre-existing" - own the codebase state

A test suite with skipped or ignored tests is a test suite you can't trust.

#### Code must work locally before pushing

**Category:** workflow

Ensure your changes work on your local machine before pushing:
- Run the application and manually verify changes
- Run the full test suite
- Check for console errors or warnings

CI is for catching environment-specific issues, not basic functionality.

#### Always use latest dependency versions

**Category:** dependencies

When adding or updating dependencies, always use the latest stable version:
- Check the official registry before adding (rubygems.org, npmjs.com, pypi.org)
- Security vulnerabilities are fixed in newer versions
- Performance improvements accumulate over time

Do NOT use older versions. If the latest version has breaking changes, fix the
code to work with the new API. Never assume migration is "too hard" without
actually attempting the upgrade first.

#### Use Rails built-in authentication, never Devise

**Category:** rails

Use Rails built-in authentication (has_secure_password, authenticate_by) for
all authentication logic. Never use Devise, Sorcery, Clearance, or similar
authentication gems.

Rails 8 provides everything needed:
- has_secure_password for password hashing
- authenticate_by for secure credential lookup
- generates_token_for for password resets and email verification

```ruby
class User < ApplicationRecord
  has_secure_password
  generates_token_for :password_reset, expires_in: 15.minutes
end
```

#### Use Strong Parameters correctly

**Category:** rails

Always use Strong Parameters to whitelist attributes:
- Define permitted params in a private method
- Never use `.permit!` which allows all attributes
- Be explicit about nested attributes
- Use `require` for the root key

```ruby
private

def user_params
  params.require(:user).permit(:name, :email, address_attributes: [:street, :city])
end
```

#### Use uv for package management

**Category:** python

Use `uv` as the default Python package manager - it's the preferred choice:
- 10-100x faster than pip/poetry
- Built-in virtual environment management
- Lockfile support (uv.lock) for reproducible builds
- Compatible with pyproject.toml and requirements.txt
- Rust-based, single binary, no Python dependency

```bash
# Install uv
curl -LsSf https://astral.sh/uv/install.sh | sh

# Create new project
uv init myproject
cd myproject

# Add dependencies
uv add fastapi sqlalchemy pydantic

# Add dev dependencies
uv add --dev pytest ruff mypy

# Run commands
uv run python main.py
uv run pytest
```

NEVER use pip, poetry, or pipenv for new projects - always use uv.

#### Never store sensitive data in plain text

**Category:** database

Encrypt or hash sensitive data:
- Passwords: Use bcrypt (has_secure_password in Rails)
- API keys: Encrypt with application-level encryption
- PII: Consider field-level encryption
- Never log sensitive data

```ruby
class User < ApplicationRecord
  has_secure_password  # Handles bcrypt hashing

  encrypts :ssn  # Rails 7+ encryption
end
```

#### Own all code in the repository

**Category:** llm-behavior

You are the only coder. Every line was written by you (this or previous sessions).
There are no "pre-existing issues" - only issues you created and haven't fixed.
Do not attribute problems to external sources or wait for someone else.

#### User defines success

**Category:** llm-behavior

You do not define success. The user and the test suite do.
Do not redefine scope, declare victory on your terms, or summarize partial progress
as completion. Done means: tests pass, linter passes, formatter run.

#### No rationalizations

**Category:** llm-behavior

Prohibited excuses: "pre-existing", "unrelated errors", "would require refactoring",
"tedious", "for now", "at this point", "tired", "frustrating", "time-consuming".
These indicate you're making excuses. Recognize them and continue working.

#### Validate and sanitize all user input

**Category:** security

Never trust user input - validate and sanitize everything:
- Use allowlists, not denylists
- Validate type, length, format, and range
- Sanitize HTML to prevent XSS
- Use parameterized queries to prevent SQL injection

```ruby
# Rails automatically escapes in views, but be explicit with user HTML:
sanitize(user_content, tags: %w[p br strong em])

# Always use parameterized queries (ActiveRecord does this by default):
User.where(email: params[:email])  # Safe
User.where("email = '#{params[:email]}'")  # DANGEROUS - SQL injection
```

#### Use HTTPS everywhere

**Category:** security

Force HTTPS for all traffic:
- Configure SSL/TLS in production
- Redirect HTTP to HTTPS
- Use secure cookies (Secure, HttpOnly, SameSite)
- Set HSTS headers

```ruby
# Rails config/environments/production.rb
config.force_ssl = true
config.ssl_options = { hsts: { expires: 1.year, subdomains: true } }
```

#### Implement proper authentication and authorization

**Category:** security

Separate authentication (who are you?) from authorization (what can you do?):

Authentication:
- Use secure password hashing (bcrypt)
- Implement rate limiting on login
- Use secure session management
- Consider MFA for sensitive applications

Authorization:
- Check permissions on every request
- Use policy objects or authorization gems (Pundit, CanCanCan)
- Never rely on client-side checks alone

```ruby
# Pundit example
def update
  @post = Post.find(params[:id])
  authorize @post  # Raises unless user can update
  @post.update!(post_params)
end
```

### High Severity

#### Mock only at external boundaries

**Category:** testing

Avoid mocking internal code or private methods. Mocks should be used only
at system boundaries:
- External HTTP APIs (use WebMock, VCR, or similar)
- Time-dependent code (freeze time with travel_to)
- File system operations that would persist outside tmp/ or create side effects
- Third-party services with rate limits or costs

Internal services, database operations, and business logic should use real
implementations to ensure proper integration.

#### TDD: Red -> Green -> Refactor

**Category:** testing

Follow Test-Driven Development for new features and bug fixes:
1. RED: Write a failing test that defines the expected behavior
2. GREEN: Write the minimum code to make the test pass
3. REFACTOR: Clean up the code while keeping tests green

This ensures every line of code has a reason to exist and is tested.

#### Run formatter, linter, and tests before commit

**Category:** workflow

Before every commit, run the full quality pipeline:
1. Format code (prettier, black, rubocop --autocorrect, etc.)
2. Run linter (eslint, pylint, rubocop, etc.)
3. Run full test suite

Never rely on CI to catch issues you could have caught locally.
Configure pre-commit hooks to enforce this automatically.

#### Use environment variables for configuration

**Category:** config

Follow 12-factor app principles for configuration:
- Store config in environment variables, not in code
- Use .env files for local development (never commit .env)
- Commit .env.example with dummy values to document required variables
- Never hardcode secrets, API keys, or connection strings

This enables the same codebase to run in any environment.

#### Use type hints everywhere

**Category:** python

Add type hints to all function signatures and class attributes:
- Enables static analysis with mypy/pyright
- Improves IDE autocompletion
- Documents expected types
- Catches type errors before runtime

```python
from typing import Optional

def process_user(user_id: int, name: str | None = None) -> dict[str, Any]:
    ...

class UserService:
    def __init__(self, repo: UserRepository) -> None:
        self.repo = repo
```

#### uv project structure

**Category:** python

Standard uv project structure:

```
myproject/
├── pyproject.toml    # Project config and dependencies
├── uv.lock           # Locked dependencies (commit this!)
├── .python-version   # Python version (e.g., "3.12")
├── src/
│   └── myproject/
│       ├── __init__.py
│       └── main.py
└── tests/
    └── test_main.py
```

Key files:
- `pyproject.toml`: Define dependencies here, not requirements.txt
- `uv.lock`: Always commit - ensures reproducible builds
- `.python-version`: uv auto-installs the correct Python version

#### Use async/await for I/O operations

**Category:** python

Use async/await for I/O-bound operations:
- HTTP requests (use httpx or aiohttp)
- Database queries (use asyncpg, databases)
- File operations (use aiofiles)

```python
import httpx

async def fetch_users() -> list[User]:
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com/users")
        return [User(**u) for u in response.json()]
```

Don't mix sync and async code - choose one paradigm per service.

#### Use Pydantic models for request/response

**Category:** fastapi

Define explicit Pydantic models for all API inputs and outputs:
- Automatic validation and documentation
- Type safety with IDE support
- Clear API contract

```python
from pydantic import BaseModel, Field

class UserCreate(BaseModel):
    email: str = Field(..., description="User email address")
    name: str = Field(..., min_length=1, max_length=100)

class UserResponse(BaseModel):
    id: int
    email: str
    name: str
    created_at: datetime

    class Config:
        from_attributes = True

@app.post("/users", response_model=UserResponse)
async def create_user(user: UserCreate) -> UserResponse:
    ...
```

#### Use dependency injection

**Category:** fastapi

Use FastAPI's Depends() for dependency injection:
- Database sessions
- Authentication
- Configuration
- External services

```python
from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    async with async_session() as session:
        yield session

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db)
) -> User:
    ...

@app.get("/me")
async def get_me(user: User = Depends(get_current_user)):
    return user
```

#### Use async database operations

**Category:** fastapi

Use async database drivers with FastAPI:
- asyncpg for PostgreSQL
- SQLAlchemy 2.0 async mode
- databases package for simple queries

```python
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession

engine = create_async_engine(
    "postgresql+asyncpg://user:pass@localhost/db",
    echo=True,
)

async def get_user(db: AsyncSession, user_id: int) -> User | None:
    result = await db.execute(
        select(User).where(User.id == user_id)
    )
    return result.scalar_one_or_none()
```

#### Use TypeScript for all new projects

**Category:** javascript

Always use TypeScript instead of plain JavaScript:
- Catch errors at compile time
- Better IDE support and refactoring
- Self-documenting code
- Safer dependency updates

Use strict mode for maximum benefit:
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

#### Use const and let, never var

**Category:** javascript

Always use `const` by default, `let` when reassignment is needed:
- `const`: Block-scoped, cannot be reassigned
- `let`: Block-scoped, can be reassigned
- `var`: Function-scoped, hoisted - NEVER USE

```typescript
// Good
const users = await fetchUsers();
let count = 0;
for (const user of users) {
  count++;
}

// Bad
var users = await fetchUsers();
```

#### Use async/await over callbacks and .then()

**Category:** javascript

Prefer async/await for asynchronous code:
- More readable than callbacks or .then() chains
- Easier error handling with try/catch
- Works naturally with loops and conditionals

```typescript
// Good
async function fetchUserData(id: string): Promise<User> {
  try {
    const response = await fetch(`/api/users/${id}`);
    if (!response.ok) throw new Error('Failed to fetch');
    return await response.json();
  } catch (error) {
    logger.error('Failed to fetch user', { id, error });
    throw error;
  }
}

// Avoid
function fetchUserData(id) {
  return fetch(`/api/users/${id}`)
    .then(res => res.json())
    .catch(err => console.log(err));
}
```

#### Use functional components with hooks

**Category:** react

Always use functional components with hooks, not class components:
- Simpler, less boilerplate
- Better TypeScript support
- Easier to test
- Hooks enable code reuse without HOCs

```tsx
// Good
function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);

  if (!user) return <Loading />;
  return <Profile user={user} />;
}

// Avoid class components
class UserProfile extends React.Component { ... }
```

#### Use React Query or SWR for data fetching

**Category:** react

Use a data fetching library instead of useEffect + fetch:
- Automatic caching and revalidation
- Loading and error states
- Optimistic updates
- Request deduplication

```tsx
import { useQuery } from '@tanstack/react-query';

function UserList() {
  const { data: users, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(r => r.json()),
  });

  if (isLoading) return <Loading />;
  if (error) return <Error message={error.message} />;
  return <List items={users} />;
}
```

#### Test behavior, not implementation

**Category:** testing

Write tests that verify behavior, not internal implementation:
- Test public interfaces, not private methods
- Focus on inputs and outputs
- Tests should survive refactoring
- If implementation changes but behavior doesn't, tests should pass

```ruby
# Good: Test behavior
test "order total includes tax" do
  order = Order.new(items: [Item.new(price: 100)])
  assert_equal 108, order.total  # 8% tax
end

# Bad: Test implementation
test "order calls calculate_tax method" do
  order = Order.new(items: [Item.new(price: 100)])
  assert order.instance_variable_get(:@tax_calculated)
end
```

#### Use RESTful conventions

**Category:** api

Follow REST conventions for predictable APIs:
- GET /resources - List all
- GET /resources/:id - Show one
- POST /resources - Create
- PUT/PATCH /resources/:id - Update
- DELETE /resources/:id - Destroy

Use nested routes for relationships:
- GET /users/:user_id/orders - User's orders
- POST /orders/:order_id/items - Add item to order

Return appropriate HTTP status codes:
- 200 OK, 201 Created, 204 No Content
- 400 Bad Request, 401 Unauthorized, 404 Not Found
- 500 Internal Server Error

### Medium Severity

#### Atomic commits with Conventional Commits

**Category:** git

Make small, focused commits that do one thing well. Use Conventional Commits:
- feat: new feature
- fix: bug fix
- refactor: code restructuring without behavior change
- test: adding or updating tests
- docs: documentation only
- chore: maintenance tasks

Example: `feat: add user authentication endpoint`

Each commit should be independently deployable and revertible.

#### Use dataclasses or Pydantic for data structures

**Category:** python

Use dataclasses for simple data containers, Pydantic for validation:

```python
from dataclasses import dataclass
from pydantic import BaseModel

# Simple data container
@dataclass
class Point:
    x: float
    y: float

# With validation (API models, config)
class UserCreate(BaseModel):
    email: str
    name: str
    age: int = Field(ge=0, le=150)
```

Avoid plain dicts for structured data - they lack type safety and validation.

#### uv scripts and commands

**Category:** python

Define scripts in pyproject.toml for common commands:

```toml
[project.scripts]
myapp = "myproject.main:main"

[tool.uv.scripts]
dev = "fastapi dev src/myproject/main.py"
test = "pytest tests/ -v"
lint = "ruff check src/"
format = "ruff format src/"
typecheck = "mypy src/"
```

Run with: `uv run dev`, `uv run test`, etc.

For CI/production:
```bash
# Install dependencies only (no dev)
uv sync --no-dev

# Export to requirements.txt if needed
uv export > requirements.txt
```

#### uv workspaces for monorepos

**Category:** python

Use uv workspaces for multi-package Python projects:

```toml
# Root pyproject.toml
[tool.uv.workspace]
members = ["packages/*"]

[tool.uv.sources]
mylib = { workspace = true }
```

Structure:
```
monorepo/
├── pyproject.toml          # Workspace root
├── uv.lock                 # Single lockfile for all packages
└── packages/
    ├── mylib/
    │   ├── pyproject.toml
    │   └── src/mylib/
    └── myapp/
        ├── pyproject.toml  # depends on mylib
        └── src/myapp/
```

Benefits:
- Single lockfile across all packages
- Local package editable installs
- Atomic dependency updates

#### Use pytest for testing

**Category:** python

Use pytest as your testing framework:
- Simple assert statements
- Powerful fixtures for setup/teardown
- Parametrized tests for multiple inputs
- Rich plugin ecosystem

```python
import pytest

@pytest.fixture
def user():
    return User(name="Test", email="test@example.com")

def test_user_full_name(user):
    assert user.full_name == "Test"

@pytest.mark.parametrize("input,expected", [
    (1, 1), (2, 4), (3, 9)
])
def test_square(input, expected):
    assert square(input) == expected
```

#### Use Black and Ruff for formatting/linting

**Category:** python

Use Black for formatting and Ruff for linting:
- Black: Uncompromising code formatter (no configuration debates)
- Ruff: Extremely fast linter (replaces flake8, isort, pylint)

```toml
# pyproject.toml
[tool.black]
line-length = 88

[tool.ruff]
line-length = 88
select = ["E", "F", "I", "N", "W", "UP"]
```

Run both in CI and pre-commit hooks.

#### Use ESLint with strict configuration

**Category:** javascript

Configure ESLint with recommended rules:
```json
{
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking"
  ],
  "rules": {
    "@typescript-eslint/no-unused-vars": "error",
    "@typescript-eslint/no-explicit-any": "error",
    "no-console": "warn"
  }
}
```

Run ESLint in CI and pre-commit hooks.

#### Avoid prop drilling with Context or state management

**Category:** react

When props need to pass through multiple levels, use Context or state management:
- React Context for static/rarely changing data
- Zustand/Jotai for simple state
- Redux Toolkit for complex state with dev tools

```tsx
// Context for auth
const AuthContext = createContext<AuthState | null>(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState<User | null>(null);
  return (
    <AuthContext.Provider value={{ user, setUser }}>
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => useContext(AuthContext);
```

#### One assertion per test (conceptually)

**Category:** testing

Each test should verify one logical concept:
- Multiple assertions are fine if they test the same thing
- Separate tests for separate behaviors
- Clear test names that describe the behavior

```ruby
# Good: One concept
test "user is invalid without email" do
  user = User.new(name: "Test")
  assert_not user.valid?
  assert_includes user.errors[:email], "can't be blank"
end

# Bad: Multiple concepts
test "user validation" do
  user = User.new
  assert_not user.valid?  # Missing everything
  user.email = "test@example.com"
  assert_not user.valid?  # Missing name
  user.name = "Test"
  assert user.valid?  # Now valid
end
```

#### Use fixtures for test data

**Category:** testing

Use fixtures for consistent test data. Fixtures are:
- Fast: loaded at database level, not through ActiveRecord
- Simple: YAML files, no DSL to learn
- Stable: good for reference data that rarely changes

```ruby
# test/fixtures/users.yml
admin:
  name: Admin User
  email: admin@example.com
  role: admin

regular:
  name: Regular User
  email: user@example.com
  role: member
```

Reference in tests with `users(:admin)`.

#### Version your APIs

**Category:** api

Include version in your API URLs or headers:
- URL versioning: `/api/v1/users`
- Header versioning: `Accept: application/vnd.api+json; version=1`

This allows you to:
- Make breaking changes without affecting existing clients
- Gradually migrate clients to new versions
- Deprecate old versions with advance notice

```ruby
# Rails routes
namespace :api do
  namespace :v1 do
    resources :users
  end
  namespace :v2 do
    resources :users
  end
end
```

#### Return consistent error responses

**Category:** api

Use a consistent error response format across all endpoints:

```json
{
  "error": {
    "code": "validation_error",
    "message": "Validation failed",
    "details": [
      { "field": "email", "message": "is invalid" },
      { "field": "name", "message": "can't be blank" }
    ]
  }
}
```

Include:
- Machine-readable error code
- Human-readable message
- Field-level details for validation errors

## Language Standards

### typescript

#### react_typescript

| Setting | Value |
|---------|-------|
| Min Version | 5.5 |
| Package Manager | pnpm |
| Test Framework | vitest |
| Linter | eslint |
| Formatter | prettier |

**Policy:** ["Use function components + hooks; avoid new class components.", "Co-locate data fetching with suspense/React Query for async state.", "Enable strict TypeScript mode."]

**Commands:**

```bash
# dev
pnpm dev
# lint
pnpm lint
# test
pnpm vitest run
# build
pnpm build
# typecheck
pnpm tsc --noEmit
```

### go

#### go_default

| Setting | Value |
|---------|-------|
| Min Version | 1.22 |
| Package Manager | go-modules |
| Test Framework | go-test |
| Linter | golangci-lint |
| Formatter | gofmt |

**Policy:** ["Use go modules for dependency management.", "Run gofmt before committing code.", "Use golangci-lint with a comprehensive config."]

**Commands:**

```bash
# lint
golangci-lint run
# test
go test ./...
# build
go build ./...
# format
gofmt -w .
```
